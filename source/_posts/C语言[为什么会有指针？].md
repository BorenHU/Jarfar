---
title: '为什么会有指针？[C语言]'
top: false
cover: false
toc: true
mathjax: false
author: 
summary: 
tags:
  - C语言
  - 指针
categories:
  - C语言
abbrlink: 26235
date: 2020-03-31 12:40:36
img:
coverImg:
password:
---

C语言指针学习

<!-- more -->

---

## 

### 1. 为什么会有指针？这门技术解决了什么问题？

转载：https://blog.csdn.net/dangbai01_/article/details/79501037

**（0）史前**

早期的CPU（也许并没有真正的实现）并不如今天的强大，

内存读写的指令(命令)只有:

“从  常数地址0x1234  地址处读入1字节到  寄存器a”，

或者“把  寄存器b  的值写入  常数地址0x5678  这个地方”。

而如果你想清空100字节的内存，每条命令只能对内存中某一个字节进行写入，那就得写100条命令。随着要处理的数据的膨胀，程序也得跟着膨胀，而这是不可接受的。

**(1）流程跳转**

为了解决清空大量内存的问题，人们发明了控制流程的命令

比如“寄存器c的值为0，则跳过下一条指令” 或 “无条件跳转到首地址为0x9012”的地方，从那个地方继续运行”。

注意，命令本身也是编码成字节存在内存里的。于是就可以写选择，循环等控制语句。

**(2）自修改程序**

但是问题并没有解决，因为就算有了选择循环结构，**整个程序还是只能写常量**，所以如果想要对不同的内存块清零，只能写不同的命令。

但是人是很聪明的。

利用“命令本身也是编码成字节存在内存里”这个特征，我们可以通过修改内存来修改命令，继而修改行为状态。

举例来说，在0x3454地址处存了一条命令，这条命令叫做“把0x5678开始的一字节清零”。

假设这条指令占用了三个字节，第一个字节告诉CPU这是一条清零指令，后两个字节（0x3455和0x3456）存了一个表示地址的整数，告诉CPU到底要把哪个字节清零。显然，这个整数会和0x5678有关。

现在，要是CPU在某处执行了一句“把起始地址为0x3455的那个2字节数自增1”，那实际上0x3454处的命令就改成了“把0x5679（0x5678+1）开始的一字节清零”。

看到希望了么，我们可以写一个命令，然后不断修改这个命令，再加上流程控制的命令产生一个循环，就能用一段固定长度（注意，代码内容随着执行并不固定）的代码清零任意指定的一段内存块！

这叫做“自修改程序”。

**(3）间接寻址**

后来的事情就很简单了。编写这种自修改程序极容易出错，因为稍微改错一个地方命令就全改乱了，比如在上例中如果把0x3454中的数字给改了，就完全变成了另一条命令，

所以人们再次发明新的工具，叫  间接寻址。

**(4）指针**

哦，现在解释指针就很简单了，指针就是间接寻址里面的内存块。它存了一片地址，而指针解引用（比如*p）就对应的是间接寻址读写的指令了。

### 2. 指针这项技术如何使用？

假如你申请一个整型变量 int a = 5；相当于把5赋值给a这个房子里，而&a就是这个房子的地址，而指针指向的就是房子的地址

而要搞清一个指针需要搞清指针的四方面的内容：

1. **指针的类型**

2. **指针所指向的类型**

3. **指针的值（指针所指向的内存区）**

4. **指针本身所占据的内存区。**

先声明几个指针放着做例子：

例一：

(1)int *ptr;

(2)char *ptr;

(3)int **ptr;

(4)int (*ptr)[3];

(5)int *(*ptr)[4];

- **指针的类型。**

从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针
本身所具有的类型。让我们看看例一中各个指针的类型：

1. int *ptr; //指针的类型是int *

2. char *ptr; //指针的类型是char *

3. int ** ptr; //指针的类型是 int **

4. int (*ptr)[3]; //指针的类型是 int(*)[3]

5. int *(*ptr)[4]; //指针的类型是 int *(*)[4]

怎么样？找出指针的类型的方法是不是很简单？

- **指针所指向的类型**

当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当
做什么来看待。

从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指
向的类型。例如：

(1)int *ptr; //指针所指向的类型是int

(2)char *ptr; //指针所指向的的类型是char

(3)int **ptr; //指针所指向的的类型是 int *

(4)int (*ptr)[3]; //指针所指向的的类型是 int()[3]

(5)int \*(*ptr)[4]; //指针所指向的的类型是 int *()[4]

在指针的算术运算中，指针所指向的类型有很大的作用。

指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把
与指针搅和在一起的“类型”这个概念分成“指针的类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。

-  **指针的值，或者叫指针所指向的内存区或地址**

指针的值是指针 本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序
里，所有类型的指针的值都是一个32位整数，因为32位程序里[内存地址](https://www.baidu.com/s?wd=内存地址&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)全都是32位长。

指针所指向的内存区就是从指针的值所代表的那个[内存地址](https://www.baidu.com/s?wd=内存地址&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)开始，长度为sizeof(指针所指向的类型)的一
片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；

我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。

指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有
了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

以后，每遇到一个指针，都应该问问：

这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪
里？

- **指针本身所占据的内存区**

指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身
占据了4个字节的长度。

指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。

#### 指针的算术运算

指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例
如：

```c
char a[20];

int *ptr=a;

ptr++;
```

在上例中，指针ptr的类型是int*它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句
中，指针ptr被加了1，编译器是这样处理的：**它把指针ptr的值加上了sizeof(int)，在32位程序中，是被
加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个
字节。**

由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了
数组a中从第4号单元开始的四个字节。

我们可以用一个指针和一个循环来遍历一个数组，看例子：

```c
int array[20];
int *ptr=array;
...
//此处略去为整型数组赋值的代码。
....
for(i=0;i<20;i++)
{
(*ptr)++;
ptr++；
}
```

这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的
下一个单元。再看例子：

```c
char a[20];

int *ptr=a;
...

...

ptr+=5;
```

在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序
中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址
来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字
节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是
可以的。这也体现出了指针的灵活性。

#### **运算符&和\* **

这里&是取地址运算符,...书上叫做“间接运算符”。&a的运算结果是一个指针，指针的类型是a的类
型加个\*，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。\*p的运算结果就五花八
门了。总之*p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址
是p所指向的地址。

```c
例五：

int a=12;

int b;

int *p;

int **ptr;
```

p=&a;

//&a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。

\*p=24;

//\*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。

ptr=&p;

//&p的结果是个指针，该指针的类型是p的类型加个\*，在这里是int\*。该指针所指向的类型是p
的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。

\*ptr=&b;

//\*ptr是个指针，&b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用
&b来给*ptr赋值就是毫无问题的了。

**ptr=34;

//\*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是
一个int类型的变量。

#### **指针表达式**

一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例
子：

```c
例六：

int a,b;

int array[10];

int *pa;

pa=&a;//&a是一个指针表达式。

int **ptr=&pa;//&pa也是一个指针表达式。

*ptr=&b;//*ptr和&b都是指针表达式。

pa=array;

pa++;//这也是指针表达式。

例七：

char *arr[20];

char *str;

str=*parr;//*parr是指针表达式

str=*(parr+1);//*(parr+1)是指针表达式

str=*(parr+2);//*(parr+2)是指针表达式
```

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所
指向的类型，指针指向的内存区，指针自身占据的内存。

好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一
个左值，否则就不是一个左值。

在例七中，&a不是一个左值，因为它还没有占据明确的内存。\*ptr是一个左值，因为\*ptr这个指针已经占
据了内存，其实\*ptr就是指针pa，既然pa已经在内存中有了自己的位置，那么*ptr当然也有了自己的位
置。

#### **数组和指针的关系**

```c
int array[10]=,value;
...
...
value=array[0];//也可写成：value=*array;
value=array[3];//也可写成：value=*(array+3);
value=array[4];//也可写成：value=*(array+4);
```

上例中，一般而言数组名array代表数组本身，类型是int [10]，但如果把array看做指针的话，它指向数
组的第0个单元，类型是int \*，所指向的类型是数组单元的类型即int。因此\*array等于0就一点也不奇怪
了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。

```c
char *str[3]={
"Hello,this is a sample!",
"Hi,good morning.",
"Hello world"
};

char s[80]；
strcpy(s,str[0]);//也可写成strcpy(s,*str);
strcpy(s,str[1]);//也可写成strcpy(s,*(str+1));
strcpy(s,str[2]);//也可写成strcpy(s,*(str+2));
```

上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指
针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char**，它指向的类型是char *。

\*str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地址是字符串"Hello,this is
a sample!"的第一个字符的地址，即'H'的地址。

str+1也是一个指针，它指向数组的第1号单元，它的类型是char**，它指向的类型是char *。

\*(str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向"Hi,good morning."的第一
个字符'H'，等等。

下面总结一下数组的数组名的问题。声明了一个数组TYPE array[n]，则数组名称array就有了两重含义：

- 第一，它代表整个数组，它的类型是TYPE [n]；

- 第二，它是一个指针，该指针的类型是TYPE*，该指针指
  向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单
  独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++
  的表达式是错误的。

在不同的表达式中数组名array可以扮演不同的角色。

在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。

在表达式\*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof
(*array)测出的是数组单元的大小。

表达式array+n（其中n=0，1，2，....。）中，array扮演的是指针，故array+n的结果是一个指针，它的
类型是TYPE*，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大
小。

```c
int array[10];
int (*ptr)[10];
ptr=&array;
```

上例中ptr是一个指针，它的类型是int (*)[10]，他指向的类型是int [10]，我们用整个数组的首地址来
初始化它。在语句ptr=&array中，array代表数组本身。

本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还
是指针所指向的类型的大小？答案是前者。例如：

```c
int (*ptr)[10];
```

则在32位程序中，有：

```c
sizeof(int(*)[10])==4
sizeof(int [10])==40
sizeof(ptr)==4
```

实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。

#### **指针和结构类型的关系**

可以声明一个指向结构类型对象的指针。

```c
struct MyStruct
{
int a;
int b;
int c;
}
```

MyStruct ss;

//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。

MyStruct *ptr=&ss;

//声明了一个指向结构对象ss的指针。它的类型是

MyStruct*,它指向的类型是MyStruct。

int \*pstr=(int*)&ss;

//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同
的。

请问怎样通过指针ptr来访问ss的三个成员变量？

答案：

ptr->a;

ptr->b;

ptr->c;

又请问怎样通过指针pstr来访问ss的三个成员变量？

答案：

*pstr；//访问了ss的成员a。

*(pstr+1);//访问了ss的成员b。

*(pstr+2)//访问了ss的成员c。

虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规
的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元：

```c
int array[3]=;

int *pa=array;

通过指针pa访问数组array的三个单元的方法是：

*pa;//访问了第0号单元

*(pa+1);//访问了第1号单元

*(pa+2);//访问了第2号单元

从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。
```

#### **指针和函数的关系**

可以把一个指针声明成为一个指向函数的指针。

```c
int fun1(char*,int);

int (*pfun1)(char*,int);

pfun1=fun1;

....

....

int a=(*pfun1)("abcdefg",7);//通过函数指针调用函数。
```

可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。

```c
int fun(char*);
int a;
char str[]="abcdefghijklmn";
a=fun(str);
...
...
int fun(char*s)
{
int num=0;
for(int i=0;i
{
num+=*s;s++;
}
return num;
}
```

这个例子中的函数fun统计一个字符串中各个字符的ASCII码值之和。前面说了，数组的名字也是一个指
针。在函数调用中，当把str作为实参传递给形参s后，实际是把str的值传递给了s，s所指向的地址就和
str所指向的地址一致，但是str和s各自占用各自的存储空间。在函数体内对s进行自加1运算，并不意味
着同时对str进行了自加1运算。

#### **指针类型转换**

当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达
式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向
的类型和指针表达式所指向的类型是一样的。

```c
float f=12.3;
float *fptr=&f;
int *p;
//在上面的例子中，假如我们想让指针p指向实数f，应该怎么搞？是用下面的语句吗？
p=&f;
```

不对。因为指针p的类型是int\*，它指向的类型是int。表达式&f的结果是一个指针，指针的类型是
float*,它指向的类型是float。两者不一致，直接赋值的方法是不行的。

p=(int*)&f;

如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP*和TYPE，那么语法格式是：

(TYPE*)p；

这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE*，它指向的类型是TYPE，它指向的地址
就是原指针指向的地址。而原来的指针p的一切属性都没有被修改。

一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，也会发生指针类型
的转换。

```c
void fun(char*);
int a=125,b;
fun((char*)&a);
...
...
void fun(char*s)
{
char c;
c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;
c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;
}
```

注意这是一个32位程序，故int类型占了四个字节，char类型占一个字节。

函数fun的作用是把一个整数的
四个字节的顺序来个颠倒。注意到了吗？

在函数调用语句中，实参&a的结果是一个指针，它的类型是int\*，它指向的类型是int。形参这个指针的类型是char\*，它指向的类型是char。

这样，在实参和形参的结合过程中，我们必须进行一次从int\*类型到char\*类型的转换。结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针 char\* temp，然后执行temp=(char * )&a，最后再把temp的
值传递给s。

所以最后的结果是：s的类型是char*,它指向的类型是char，它指向的地址就是a的首地址。

我们已经知道，指针的值就是指针指向的地址，在32位程序中，指针的值其实是一个32位整数。那可不可
以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：

```c
unsigned int a;
TYPE *ptr;//TYPE是int，char或结构类型等等类型。
...
...
a=20345686;
ptr=20345686;//我们的目的是要使指针ptr指向地址20345686（十进制）
ptr=a;//我们的目的是要使指针ptr指向地址20345686（十进制）
```

编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：

```c
unsigned int a;
TYPE *ptr;//TYPE是int，char或结构类型等等类型。
...
...
a=某个数，这个数必须代表一个合法的地址；
ptr=(TYPE*)a；//呵呵，这就可以了。
```

严格说来这里的(TYPE\*)和指针类型转换中的(TYPE\*)还不一样。这里的(TYPE*)的意思是把[无符号整数](https://www.baidu.com/s?wd=无符号整数&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)a的
值当作一个地址来看待。

上面强调了a的值必须代表一个合法的地址，否则的话，在你使用ptr的时候，就会出现[非法操作](https://www.baidu.com/s?wd=非法操作&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)错误。

想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把
一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：

```c
int a=123,b;
int *ptr=&a;
char *str;
b=(int)ptr;//把指针ptr的值当作一个整数取出来。
str=(char*)b;//把这个整数的值当作一个地址赋给指针str。
```

好了，现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一
个指针。

